#' @return
#' La funzione ritorna l'andamento e il rendimento del fondo, i decessi e il premio che ciascun assicurato dovrà pagare
#'
#' @export
#'
#' @examples
#'
gestionePortafoglio = function(#input
numeroAssicurati = 1000,
eta = 20,
rata = 1000,
fondoInizio = 100000,
numeroPremi = 15,
omega = 110,
differimento = 25,
temporanea = FALSE,
# temporanea o  vita intera
anniCopertura = 35,
rateGarantiteDurata = 5,
rendimentoFondoAnnuo = 0.02,
# tasso finanziario
tassoAleatorio = TRUE,
tavolaMortalita = demoIta$RG48M,
#tavola utilizzata per la base tecnica
tassoTecnico = 0.02,
#tasso utilizzato per la base tecnica
tavolaPeriodo = demoIta$SIM02) {
# tavola utilizzata per calcolare i morti nel portafoglio
# vengono inizializzati gli output
andamentoFondo = NULL
rendimentoFondo = NULL
decessi = NULL
# Fissiamo gli anni di copertura nel caso di una vitalizia
if (!temporanea)
{
anniCopertura = omega - eta
}
calcoloVettoreTasso = function()
{
#il tasso si distribuisce come una normale
ifelse(tassoAleatorio, return(rnorm(
anniCopertura, mean = rendimentoFondoAnnuo, sd = 0.01
)), return(rep(rendimentoFondoAnnuo, anniCopertura)))
# accettiamo la possibilità di deflazione nel caso del aleatorio
}
tassoFinanziario = calcoloVettoreTasso()
# calcola quante persone muoiono nel fondo
calcoloDecessi = function()
{
died = NULL
for (i in eta:(anniCopertura + eta))
{
sopravissuti = numeroAssicurati - sum(died)
#mu = probabilità di decesso nell'anno i condizionatamente che siano in vita all'anno i
mu =  (tavolaPeriodo[i + 1] - ifelse(i > (omega - 2), 0, tavolaPeriodo[i +
2])) / ifelse(i > (omega - 1), 1, tavolaPeriodo[i + 1])
#genera i morti da una normale con media quelli che in linea teorica dovrebbero morire
mortiCasuali = abs(rnorm(1, sopravissuti * mu, mu))
#arrotonda agli interi il numero di morti e nel caso sia > dei sopravissuti, li uccide tutti
died = round(c(
died,
ifelse(mortiCasuali > sopravissuti, sopravissuti, mortiCasuali)
),
digits = 0) #le persone sono interi e quindi si arrotonda a degli interi
}
return(died)
}
# calcola gli hPx tramite l_(x+h) / l_x
hPx = function(h, x)
{
# il +1 è per compensare che in R i vettori partono da 1 mentre l'età parte da zero
# ifelse serve a evitare il problema dell'età limite di andare fuori dal vettore
return(ifelse(h + x > omega - 1, 0, tavolaMortalita[h + x + 1]) / tavolaMortalita[x + 1])
}
# assicurati vivi
hAV = function(h)
# indica al tempo t il numero di assicurati sopravissuti
{
return(numeroAssicurati - ifelse(h > 0, sum(decessi[1:h]), 0))
}
# PREMIO
premio = function()
{
if (rateGarantiteDurata > 0)
{
p = rata * (sum((1 + tassoTecnico) ** -c((differimento + 1):(differimento + 1 + rateGarantiteDurata)
)) + sum((1 + tassoTecnico) ** -c((differimento + 1 + rateGarantiteDurata):anniCopertura
) * hPx(c((differimento + 1 + rateGarantiteDurata):anniCopertura
), eta)))
if (numeroPremi == 1)
{
return(p)
} else
{
return(p / sum((1 + tassoTecnico) ** -c(0:(
numeroPremi - 1
)) * hPx(c(
0:(numeroPremi - 1)
), eta))) # parte da zero perché la prima la pagano tutti
}
} else
{
p = rata * sum((1 + tassoTecnico) ** -(c((
differimento + 1
):anniCopertura)) * hPx(c((
differimento + 1
):anniCopertura), eta))
if (numeroPremi == 1)
{
return(p)
} else
{
return(p / sum((1 + tassoTecnico) ** -c(0:(
numeroPremi - 1
)) * hPx(c(
0:(numeroPremi - 1)
), eta))) # parte da zero perché la prima la pagano tutti
}
}
return(-1) # nel caso l'utente inserisca rate garantite negative. Sì potrebbe mettere un try and catch
}
# INIZIO ANDAMENTO E RENDIMENTO
# calcolo dei vari decessi
decessi = calcoloDecessi()
#Utilizzo della forumula ricorsiva
# incasso dei premi e differimento
if (differimento > 0) {
for (t in 1:(differimento))
{
andamentoFondo = c(andamentoFondo,
(
ifelse(t > numeroPremi, 0, hAV(t) * premio()) +
ifelse(t > 1, andamentoFondo[t -
1], fondoInizio)
) * (1 + tassoFinanziario[t]))
rendimentoFondo = c(rendimentoFondo,
andamentoFondo[t] - ifelse(t > 1, andamentoFondo[t - 1], fondoInizio))
}
}
# calcolo del fondo dall'inizio del pagamento delle rate
for (t in (differimento + 1):(anniCopertura))
{
andamentoFondo = c(andamentoFondo, (
ifelse(
t > 1,
andamentoFondo[t - 1],
fondoInizio + premio() * numeroAssicurati
) -
(
rata * ifelse((t - differimento) > rateGarantiteDurata,
hAV(t + 1),
numeroAssicurati
)
)
) * (1 + tassoFinanziario[t]))
rendimentoFondo = c(rendimentoFondo,
andamentoFondo[t] - ifelse(t > 1, andamentoFondo[t - 1], fondoInizio))
}
#Creazione dell'oggetto che la funzione dovrà tornare
Output = new.env()
Output$andamentoFondo = andamentoFondo
Output$rendimentoFondo = rendimentoFondo
Output$decessi = decessi
Output$premio = premio()
return(Output)
}
library(lifecontingencies)
#' Gestione Portafoglio
#' Dato un portafoglio, di rischi omogenei tra loro, la funzione calcola rendimento e andamento del fondo e i decessi
#'
#' @param numeroAssicurati
#' @param eta età degli assicurati
#' @param rata importo della rata annuale
#' @param fondoInizio importo iniziale del fondo
#' @param numeroPremi numero di premi che gli assicurati pagheranno
#' @param omega età massima raggiungibile
#' @param differimento rendita differita o immediata
#' @param temporanea rendita vitalizia o temporanea
#' @param anniCopertura anni di coperrtura nel caso di rendita temporanea
#' @param rateGarantiteDurata numero di rate garantite
#' @param rendimentoFondoAnnuo tasso di rendimento del fondo
#' @param tassoAleatorio tasso fisso o aleatorio
#' @param tavolaMortalita tavola di mortalità con cui calcolare il premio
#' @param tassoTecnico tasso usato per calcolare il premio
#' @param tavolaPeriodo tavola utilizzata per simulare i decessi all'interno del portafoglio
#'
#' @return
#' La funzione ritorna l'andamento e il rendimento del fondo, i decessi e il premio che ciascun assicurato dovrà pagare
#'
#' @export
#'
#' @examples
#'
gestionePortafoglio = function(#input
numeroAssicurati = 1000,
eta = 20,
rata = 1000,
fondoInizio = 100000,
numeroPremi = 15,
omega = 110,
differimento = 25,
temporanea = FALSE,
# temporanea o  vita intera
anniCopertura = 35,
rateGarantiteDurata = 5,
rendimentoFondoAnnuo = 0.02,
# tasso finanziario
tassoAleatorio = TRUE,
tavolaMortalita = demoIta$RG48M,
#tavola utilizzata per la base tecnica
tassoTecnico = 0.02,
#tasso utilizzato per la base tecnica
tavolaPeriodo = demoIta$SIM02) {
# tavola utilizzata per calcolare i morti nel portafoglio
# vengono inizializzati gli output
andamentoFondo = NULL
rendimentoFondo = NULL
decessi = NULL
# Fissiamo gli anni di copertura nel caso di una vitalizia
if (!temporanea)
{
anniCopertura = omega - eta
}
calcoloVettoreTasso = function()
{
#il tasso si distribuisce come una normale
ifelse(tassoAleatorio, return(rnorm(
anniCopertura, mean = rendimentoFondoAnnuo, sd = 0.01
)), return(rep(rendimentoFondoAnnuo, anniCopertura)))
# accettiamo la possibilità di deflazione nel caso del aleatorio
}
tassoFinanziario = calcoloVettoreTasso()
# calcola quante persone muoiono nel fondo
calcoloDecessi = function()
{
died = NULL
for (i in eta:(anniCopertura + eta))
{
sopravissuti = numeroAssicurati - sum(died)
#mu = probabilità di decesso nell'anno i condizionatamente che siano in vita all'anno i
mu =  (tavolaPeriodo[i + 1] - ifelse(i > (omega - 2), 0, tavolaPeriodo[i +
2])) / ifelse(i > (omega - 1), 1, tavolaPeriodo[i + 1])
#genera i morti da una normale con media quelli che in linea teorica dovrebbero morire
mortiCasuali = abs(rnorm(1, sopravissuti * mu, mu))
#arrotonda agli interi il numero di morti e nel caso sia > dei sopravissuti, li uccide tutti
died = round(c(
died,
ifelse(mortiCasuali > sopravissuti, sopravissuti, mortiCasuali)
),
digits = 0) #le persone sono interi e quindi si arrotonda a degli interi
}
return(died)
}
# calcola gli hPx tramite l_(x+h) / l_x
hPx = function(h, x)
{
# il +1 è per compensare che in R i vettori partono da 1 mentre l'età parte da zero
# ifelse serve a evitare il problema dell'età limite di andare fuori dal vettore
return(ifelse(h + x > omega - 1, 0, tavolaMortalita[h + x + 1]) / tavolaMortalita[x + 1])
}
# assicurati vivi
hAV = function(h)
# indica al tempo t il numero di assicurati sopravissuti
{
return(numeroAssicurati - ifelse(h > 0, sum(decessi[1:h]), 0))
}
# PREMIO
premio = function()
{
if (rateGarantiteDurata > 0)
{
p = rata * (sum((1 + tassoTecnico) ** -c((differimento + 1):(differimento + 1 + rateGarantiteDurata)
)) + sum((1 + tassoTecnico) ** -c((differimento + 1 + rateGarantiteDurata):anniCopertura
) * hPx(c((differimento + 1 + rateGarantiteDurata):anniCopertura
), eta)))
if (numeroPremi == 1)
{
return(p)
} else
{
return(p / sum((1 + tassoTecnico) ** -c(0:(
numeroPremi - 1
)) * hPx(c(
0:(numeroPremi - 1)
), eta))) # parte da zero perché la prima la pagano tutti
}
} else
{
p = rata * sum((1 + tassoTecnico) ** -(c((
differimento + 1
):anniCopertura)) * hPx(c((
differimento + 1
):anniCopertura), eta))
if (numeroPremi == 1)
{
return(p)
} else
{
return(p / sum((1 + tassoTecnico) ** -c(0:(
numeroPremi - 1
)) * hPx(c(
0:(numeroPremi - 1)
), eta))) # parte da zero perché la prima la pagano tutti
}
}
return(-1) # nel caso l'utente inserisca rate garantite negative. Sì potrebbe mettere un try and catch
}
# INIZIO ANDAMENTO E RENDIMENTO
# calcolo dei vari decessi
decessi = calcoloDecessi()
#Utilizzo della forumula ricorsiva
# incasso dei premi e differimento
if (differimento > 0) {
for (t in 1:(differimento))
{
andamentoFondo = c(andamentoFondo,
(
ifelse(t > numeroPremi, 0, hAV(t) * premio()) +
ifelse(t > 1, andamentoFondo[t -
1], fondoInizio)
) * (1 + tassoFinanziario[t]))
rendimentoFondo = c(rendimentoFondo,
andamentoFondo[t] - ifelse(t > 1, andamentoFondo[t - 1], fondoInizio))
}
}
# calcolo del fondo dall'inizio del pagamento delle rate
for (t in (differimento + 1):(anniCopertura))
{
andamentoFondo = c(andamentoFondo, (
ifelse(
t > 1,
andamentoFondo[t - 1],
fondoInizio + premio() * numeroAssicurati
) -
(
rata * ifelse((t - differimento) > rateGarantiteDurata,
hAV(t + 1),
numeroAssicurati
)
)
) * (1 + tassoFinanziario[t]))
rendimentoFondo = c(rendimentoFondo,
andamentoFondo[t] - ifelse(t > 1, andamentoFondo[t - 1], fondoInizio))
}
#Creazione dell'oggetto che la funzione dovrà tornare
Output = new.env()
Output$andamentoFondo = andamentoFondo
Output$rendimentoFondo = rendimentoFondo
Output$decessi = decessi
Output$premio = premio()
return(Output)
}
o=gestionePortafoglio(numeroAssicurati = 1000,eta = 30,rata = 12000,fondoInizio = 10000,numeroPremi = 30,differimento = 30,temporanea = TRUE,anniCopertura = 40,rendimentoFondoAnnuo = 0.018,tassoTecnico = 0.02,tassoAleatorio = TRUE)
print(o$premio)
plot(y = o$andamentoFondo,x = c(31:70),type="l")
abline(h=0)
plot(y = o$rendimentoFondo,x = c(31:70),type="l")
abline(h=0)
#' MonteCarlo
#'
#' @param x
#' @param level
#' @param numeroMomenti
#'
#' @return
#' @export
#'
#' @examples
MonteCarlo <- function(x,
level = 0.95,
numeroMomenti = 10)
{
monteCarlo = new.env()
nSimulazioni = length(x)
monteCarlo$valAtteso = mean(x)
monteCarlo$varianzaCampionaria = sd(x) / sqrt(nSimulazioni - 1)
#lower tail = false indica che la prob diverta 1-alpha al posto di alpha
z = qnorm((1 - level) / 2, lower.tail = FALSE)
intConfLow = monteCarlo$valAtteso - z * monteCarlo$varianzaCampionaria
intConfUp = monteCarlo$valAtteso + z * monteCarlo$varianzaCampionaria
monteCarlo$intervalloConfidenza = c(intConfLow, intConfUp)
for (i in 1:numeroMomenti)
{
monteCarlo$momenti[i] = mean(x ** i)
}
#probabilità di rovina
rovine=0
for (i in 1:length(x))
{
rovine = rovine+ifelse(x[i] < 0, 1, 0)
}
monteCarlo$rovina = rovine / length(x)
return(monteCarlo)
}
x=0
for (i in 1:10**3)
{
x[i] = gestionePortafoglio(
fondoInizio = 1000,
numeroAssicurati = 100,
tassoAleatorio = 0.01,
tassoTecnico = 0.02
)$andamentoFondo[90]
}
MonteCarlo(x)$valAtteso
MonteCarlo(x)$intervalloConfidenza
MonteCarlo(x)$rovina
#' Capitale Minimo
#'
#' @param numeroAssicurati
#' @param eta
#' @param rata
#' @param numeroPremi
#' @param omega
#' @param differimento
#' @param temporanea
#' @param anniCopertura
#' @param rateGarantiteDurata
#' @param rendimentoFondoAnnuo
#' @param tassoAleatorio
#' @param tavolaMortalita
#' @param tassoTecnico
#' @param tavolaPeriodo
#' @param andamentoFondo
#' @param rendimentoFondo
#' @param decessi
#' @param precisione
#'
#' @return
#' @export
#'
#' @examples
capitaleMinimo = function (numeroAssicurati = 1000,
eta = 20,
rata = 1000,
numeroPremi = 15,
omega = 110,
differimento = 25,
temporanea = FALSE,
# temporanea o  vita intera
anniCopertura = 35,
rateGarantiteDurata = 5,
rendimentoFondoAnnuo = 0.01,
# tasso finanziario
tassoAleatorio = TRUE,
tavolaMortalita = demoIta$RG48M,
#tavola utilizzata per la base tecnica
tassoTecnico = 0.02,
#tasso utilizzato per la base tecnica
tavolaPeriodo = demoIta$SIM02,
precisione = 1000, anno = 90)
{
capitaleMinimo = 0
x = 0
for (i in 1:precisione)
{
x[i] =
gestionePortafoglio(
numeroAssicurati = numeroAssicurati,
eta = eta,
rata = rata,
numeroPremi = numeroPremi,
omega = omega,
differimento = differimento,
temporanea = temporanea,
anniCopertura = anniCopertura,
rateGarantiteDurata = rateGarantiteDurata,
rendimentoFondoAnnuo = rendimentoFondoAnnuo,
tassoAleatorio = tassoAleatorio,
tavolaMortalita = tavolaMortalita,
tassoTecnico = tassoTecnico,
tavolaPeriodo = tavolaPeriodo,
fondoInizio = capitaleMinimo
)$andamentoFondo[anno]
}
while (MonteCarlo(x)$rovina > 0.05)
{
capitaleMinimo = capitaleMinimo + abs(quantile(x, probs = 0.05)) / ifelse(MonteCarlo(x)$rovina > 0.9,
8,
ifelse(
MonteCarlo(x)$rovina > 0.1,
20,
ifelse(MonteCarlo(x)$rovina > 0.08, 30, 40)
))
print(capitaleMinimo)
probabilitaRovina = MonteCarlo(x)$rovina
print(probabilitaRovina)
for (i in 1:precisione)
{
x[i] = gestionePortafoglio(
numeroAssicurati = numeroAssicurati,
eta = eta,
rata = rata,
numeroPremi = numeroPremi,
omega = omega,
differimento = differimento,
temporanea = temporanea,
anniCopertura = anniCopertura,
rateGarantiteDurata = rateGarantiteDurata,
rendimentoFondoAnnuo = rendimentoFondoAnnuo,
tassoAleatorio = tassoAleatorio,
tavolaMortalita = tavolaMortalita,
tassoTecnico = tassoTecnico,
tavolaPeriodo = tavolaPeriodo,
fondoInizio = capitaleMinimo
)$andamentoFondo[anno]
}
}
return(capitaleMinimo)
}
capitaleMinimo(rendimentoFondoAnnuo = 0.015,tassoTecnico = 0.02,precisione = 100)
86/12
